package org.usfirst.frc.team1160.robot.motionProfiling;

import org.usfirst.frc.team1160.robot.MotionProfile;
import org.usfirst.frc.team1160.robot.Robot;
import org.usfirst.frc.team1160.robot.RobotMap;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class FollowInvertedProfile extends Command implements RobotMap {

	private MotionProfile profile;
	private int currentPoint;
	private double timeout;

	public FollowInvertedProfile(MotionProfile profile, double timeout) {

		requires(Robot.dt);
		this.profile = profile;
		this.timeout = timeout;
		currentPoint = 0;
	}

	protected void initialize() {
		Robot.dt.resetPos();
		Robot.dt.startTime();
		//System.out.println(profile.getNumFinalPoints());
	}

	protected void execute() {
		currentPoint= (int)(Robot.dt.getTime()*profile.getPointsPerSecond());
		
		// desired_position, desired_velocity, and desired_acceleration are all
		// generated by your profile.
		double leftOutput = calculateLeftOutput(profile, currentPoint);
		double rightOutput = calculateRightOutput(profile, currentPoint);
		
		Robot.dt.setLeft(-leftOutput);
		Robot.dt.setRight(rightOutput);
		System.out.println(Robot.dt.getTime());
		
		Robot.dt.logData();
	}
	

	public double calculateRightOutput(MotionProfile profile, int currentPoint) {

		if (currentPoint < profile.getNumFinalPoints()) {
			double position_error = profile.getRightPosition()[currentPoint] + Robot.dt.getRightPosition()/DT_WHEEL_CIRC_FT;
			double velocity_error = profile.getRightVelocity()[currentPoint] - Robot.dt.getRightSpeed()*DT_WHEEL_CIRC_FT/60;

			double output = MOTIONPROFILE_KV_RIGHT * profile.getRightVelocity()[currentPoint]/DT_WHEEL_CIRC_FT
					+ MOTIONPROFILE_KA_RIGHT * profile.getRightAcceleration()[currentPoint] + MOTIONPROFILE_KP_RIGHT * position_error/DT_WHEEL_CIRC_FT;
			return output;
		}

		else
			return (0);

	}

	public double calculateLeftOutput(MotionProfile profile, int currentPoint) {

		if (currentPoint < profile.getNumFinalPoints()) {
			double position_error = profile.getLeftPosition()[currentPoint] - Robot.dt.getLeftPosition()*DT_WHEEL_CIRC_FT;
			double velocity_error = profile.getLeftVelocity()[currentPoint] - Robot.dt.getLeftSpeed()*DT_WHEEL_CIRC_FT/60;

			
			double output = MOTIONPROFILE_KV_LEFT * profile.getLeftVelocity()[currentPoint]
					+ MOTIONPROFILE_KA_LEFT * profile.getLeftAcceleration()[currentPoint] + MOTIONPROFILE_KP_LEFT * position_error;
			return output;
		}

		else
			return (0);

	}
	
	protected void interrupted(){
		Robot.dt.resetPos();
		Robot.dt.set(0);
	}
	
	protected void end(){
		Robot.dt.resetPos();
		Robot.dt.set(0);
	}
	@Override
	protected boolean isFinished() {
		return(Robot.dt.getTime()>timeout);
	}

}
